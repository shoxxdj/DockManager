{
  "name": "waitforit",
  "version": "0.0.5",
  "description": "A simple utility for dealing with parallel async code",
  "main": "index.js",
  "scripts": {
    "test": "mocha"
  },
  "devDependencies": {
    "mocha": "1.14.0"
  },
  "keywords": [
    "parallel",
    "execution",
    "callback",
    "async",
    "wait",
    "waitfor",
    "waitforit"
  ],
  "author": {
    "name": "Arnor Heidar Sigurdsson",
    "email": "arnorhs@gmail.com"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git://github.com/arnorhs/waitforit.git"
  },
  "bugs": {
    "url": "https://github.com/arnorhs/waitforit/issues"
  },
  "readme": "# wait for it..\nA simple module for parallel execution with a shared complete callback.\n\nYou can use it basically any time you have more than one events that need to\nhappen before you take action, where it is not important which event happens\nfirst.\n\nExamples:\n- doing more than one database call where the results don't depend on each other\n- reading multiple files from disk\n- doing two web requests at the same time\n\nNote: It should work in the browser as well, but hasn't been packaged yet for easy\nusage, nor has it been tested very thoroughly.\n\n### Usage:\n\nInstall using:\n```\nnpm install waitforit\n```\n\nStart two async calls that can run in parallel:\n```javascript\nvar waitforit = require('waitforit');\n\nvar wait = waitforit(function(err) {\n    console.log(\"Complete called\");\n});\n\nvar first = wait();\nsetTimeout(function() {\n    first();\n}, Math.random() * 1000);\n\nvar second = wait();\nsetTimeout(function() {\n    second();\n}, Math.random() * 1000);\n```\n\nHave the callbacks return results:\n```javascript\nvar wait = waitforit(function(err, results) {\n    console.log(\"Complete called with results: \", results);\n    // results will be {\"key 1\": \"value 1\", \"key 2\": \"value 2\"}\n});\n\nvar first = wait('key 1');\nsetTimeout(function() {\n    first('value 1');\n}, Math.random() * 1000);\n\nvar second = wait('key 2');\nsetTimeout(function() {\n    second('value 2');\n}, Math.random() * 1000);\n```\n\nSometimes you might not have generated all the async handlers right away, or you want to have\nthe handlers called multiple times (with the last result overriding the previous) you can\ncontrol whether or not you're done by returning a boolean for whether or not it's done in the\ncomplete callback.\n```javascript\nvar wait = waitforit(function(err, results) {\n    if (!results.key1 || !results.key2) {\n        return false;\n    }\n    // do something with the results\n});\n```\n\nIn many cases you can just pass the async handlers straight into async calls, eg. with reading\nfiles, you can do something like:\n```javascript\nvar fs = require('fs'),\n    waitforit = require('waitforit');\n\nvar wait = waitforit(function(err, files) {\n    if (err) {\n        throw new Error(\"couldn't really read any files\");\n    }\n    // do something with files.file1, files.file2\n});\n\nfs.readFile('file1.txt', 'utf-8', wait('file1'));\nfs.readFile('file2.txt', 'utf-8', wait('file2'));\n```\n\nNote that the final callback will be called immediately if any of the async handlers get passed\nan error.\n\n### License\nMIT\n\n### TODO:\n- maybe support cancelling?\n",
  "readmeFilename": "README.md",
  "_id": "waitforit@0.0.5",
  "dist": {
    "shasum": "b46ff3f323391a921d9491abe857f4c71dd7fe6d",
    "tarball": "http://registry.npmjs.org/waitforit/-/waitforit-0.0.5.tgz"
  },
  "_from": "waitforit@*",
  "_npmVersion": "1.3.11",
  "_npmUser": {
    "name": "arnorhs",
    "email": "arnorhs@gmail.com"
  },
  "maintainers": [
    {
      "name": "arnorhs",
      "email": "arnorhs@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "b46ff3f323391a921d9491abe857f4c71dd7fe6d",
  "_resolved": "https://registry.npmjs.org/waitforit/-/waitforit-0.0.5.tgz"
}
